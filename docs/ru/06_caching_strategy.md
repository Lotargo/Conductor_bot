# Стратегия кэширования

Для обеспечения высокой производительности и сокращения избыточных вычислений в Sentio Engine реализован слой кэширования на уровне API. Этот документ описывает механизм кэширования на стороне сервера и предоставляет рекомендации по кэшированию на стороне клиента.

## Серверное кэширование: `POST /process_and_report`

Основной механизм кэширования встроен в эндпоинт `POST /process_and_report`. Этот эндпоинт предназначен для stateless-взаимодействий, где одни и те же входные данные должны последовательно производить один и тот же первоначальный результат.

### Как это работает

1.  **Хеширование запроса:** При получении запроса движок вычисляет **хеш SHA-256** от бинарного содержимого сообщения `Stimulus`. Этот хеш служит уникальным ключом для запроса.

2.  **Поиск в кэше:** Движок проверяет наличие этого ключа в **кэше Redis**.

3.  **Попадание в кэш (Cache Hit):** Если ключ найден, соответствующее сообщение `Report` извлекается из Redis и немедленно возвращается клиенту. Ядро движка (Core Engine) не задействуется, и внутреннее состояние движка не изменяется. Это происходит чрезвычайно быстро.

4.  **Промах кэша (Cache Miss):** Если ключ не найден, запрос обрабатывается в обычном порядке:
    *   `Stimulus` отправляется в ядро движка.
    *   Внутреннее состояние движка обновляется.
    *   Генерируется новый `Report`.
    *   Новый `Report` сохраняется в Redis, используя хеш в качестве ключа.
    *   `Report` возвращается клиенту.

5.  **Время жизни (TTL):** Записи в кэше автоматически истекают через **1 час**. Это обеспечивает баланс между производительностью и гарантией того, что состояние не станет чрезмерно устаревшим, если изменится базовая конфигурация личности.

### Диаграмма последовательности (Логика кэша)

Эта диаграмма иллюстрирует процесс принятия решений на уровне API при получении запроса.

```mermaid
graph TD
    A[Клиент отправляет POST /process_and_report] --> B{Вычислить хеш Stimulus};
    B --> C{Ключ существует в Redis?};
    C -- Да (Попадание в кэш) --> D[Извлечь Report из Redis];
    D --> F[Вернуть кэшированный Report клиенту];
    C -- Нет (Промах кэша) --> E[Обработать Stimulus ядром движка];
    E --> G[Сгенерировать новый Report];
    G --> H[Сохранить Report в Redis (ключ=хеш, TTL=1ч)];
    H --> I[Вернуть новый Report клиенту];
```

## Клиентское кэширование (Рекомендуется)

Для приложений, которые часто отправляют одни и те же стимулы, мы настоятельно рекомендуем реализовать локальный слой кэширования на стороне клиента. Это может предотвратить даже сетевой запрос, что еще больше снизит задержку.

### Пример (Python)

Вот простой пример с использованием словаря в качестве кэша в памяти. Для более надежных решений можно использовать библиотеки, такие как `cachetools`.

```python
import requests
from sentio_engine.schemas.sentio_pb2 import Stimulus, Report

# Простой кэш в памяти
client_side_cache = {}

def get_cached_report(stimulus: Stimulus) -> Report:
    """
    Обрабатывает стимул, используя локальный кэш для избежания
    избыточных вызовов API.
    """
    # Создаем ключ кэша из данных стимула
    cache_key = stimulus.SerializeToString()

    # Сначала проверяем локальный кэш
    if cache_key in client_side_cache:
        print("Попадание в кэш клиента!")
        report = Report()
        report.ParseFromString(client_side_cache[cache_key])
        return report

    # Если в локальном кэше нет, вызываем API
    print("Промах кэша клиента. Вызов API...")
    response = requests.post(
        "http://127.0.0.1:8000/process_and_report",
        data=cache_key,
        headers={'Content-Type': 'application/protobuf'}
    )

    if response.status_code == 200:
        # Сохраняем ответ в локальном кэше
        client_side_cache[cache_key] = response.content

        # Парсим и возвращаем отчет
        report = Report()
        report.ParseFromString(response.content)
        return report
    else:
        # Обрабатываем ошибки соответствующим образом
        response.raise_for_status()

# --- Использование ---
stimulus_A = Stimulus()
stimulus_A.emotions["радость"] = 0.8

# Первый вызов: будет промах в кэше клиента и сервера
print("Первый вызов для Stimulus A:")
get_cached_report(stimulus_A)

# Второй вызов: будет попадание в кэш клиента
print("\nВторой вызов для Stimulus A:")
get_cached_report(stimulus_A)
```

---

**Далее:** [Руководство по тестированию](./07_testing.md)
