# Подробный обзор архитектуры

Sentio Engine спроектирован как модульный и слабосвязанный микросервис. Такая архитектура гарантирует, что ядро эмоциональной обработки изолировано и может быть интегрировано в различные внешние системы без жесткой связи.

Ниже представлено подробное описание каждого компонента и его роли в экосистеме.

## Диаграмма компонентов

```mermaid
graph LR
    subgraph Внешние Системы
        direction LR
        A[LLM-парсер] -- Protobuf --> B{API Sentio Engine};
        B -- Protobuf --> C[LLM-генератор];
    end

    subgraph Сервис Sentio Engine
        direction TB
        B -- HTTP-запрос --> D[Сервер FastAPI];
        D -- Вызовы --> E[Ядро Движка];
        E -- Чтение --> F[Конфиги Личности (.json)];
        E -- Чтение/Запись --> G[(База данных SQLite)];
    end

    style A fill:#cce5ff,stroke:#333
    style C fill:#cce5ff,stroke:#333
    style B fill:#f9f,stroke:#333,stroke-width:2px
    style E fill:#ccffcc,stroke:#333
```

## Описание компонентов

### 1. Внешние системы

Эти компоненты не являются частью сервиса Sentio Engine, но являются его основными потребителями.

*   **LLM-парсер:** Это концептуальный компонент (например, функция в бэкенде вашего чат-бота), отвечающий за анализ пользовательского ввода (текст, голос и т.д.) и его преобразование в эмоциональный **Стимул**.
    *   *Пример:* Пользователь говорит: «Вау, спасибо вам огромное!» Парсер анализирует это и генерирует Protobuf-сообщение: `Stimulus(emotions={"благодарность": 0.8, "радость": 0.6})`.
*   **LLM-генератор:** Это основная LLM вашего приложения. Она получает эмоциональный **Отчет** от Sentio Engine и использует его для стилизации своего ответа. Отчет можно внедрить в системный промпт, чтобы направить тон и содержание генерируемого текста.

### 2. API Sentio Engine

Единая точка входа в сервис.

*   **Технология:** **FastAPI**.
*   **Протокол:** **Protocol Buffers (Protobuf)** через HTTP. Это обеспечивает высокую производительность и строго типизированные контракты между сервисом и его клиентами.
*   **Эндпоинты:**
    *   `POST /stimulus`: Принимает сообщение `Stimulus` для обновления состояния движка.
    *   `GET /report`: Возвращает сообщение `Report`, детализирующее текущее эмоциональное состояние.

### 3. Ядро Движка (класс `SentioEngine`)

Это сердце сервиса, где происходит вся эмоциональная обработка.

*   **Обязанности:**
    *   **Управление состоянием:** Хранит текущее `EmotionalState` в памяти (краткосрочная память).
    *   **Загрузка конфигурации:** При запуске загружает «личность» из JSON-файлов конфигурации.
    *   **Обработка стимулов:** Применяет математические модели для обновления эмоционального состояния на основе входящих стимулов.
    *   **Затухание эмоций:** Симулирует естественное угасание эмоций со временем, заставляя их возвращаться к базовому уровню.
    *   **Взаимодействие с БД:** Записывает значительные эмоциональные изменения в долгосрочную память (базу данных SQLite).

### 4. Конфиги Личности (файлы `.json`)

Эти файлы определяют уникальную «ДНК» личности ИИ. Они загружаются один раз при запуске.

*   **`emotions.json`:** Определяет все возможные эмоции, их базовую интенсивность и скорость затухания.
*   **`drives.json`:** (Будущее расширение) Может использоваться для определения основных мотиваций, таких как «любопытство» или «социальная связь», которые влияют на эмоциональные реакции.
*   **`BeliefSystem.json`:** (Будущее расширение) Может определять основные ценности, которые могут усиливать или подавлять определенные эмоции.

### 5. База данных SQLite (Долгосрочная память)

База данных обеспечивает персистентность и ощущение истории.

*   **Технология:** **SQLAlchemy** с бэкендом **SQLite**.
*   **Таблицы:**
    *   `EmotionalHistory`: Журнал всех значительных эмоциональных изменений, предоставляющий временную шкалу «чувств» ИИ.
    *   `EmotionalMemory`: (Будущее расширение) Может хранить мощные «триггеры» — ассоциации между конкретными стимулами и сильными эмоциональными реакциями (например, травмы или дорогие воспоминания).
    *   `RelationshipState`: (Будущее расширение) Может отслеживать метрики отношений (например, доверие, близость) с разными пользователями.

Эта архитектура обеспечивает чистое разделение ответственности, делая систему масштабируемой, тестируемой и легкой в обслуживании.

---

**Далее:** [Справочник по API](./03_api_reference.md)
